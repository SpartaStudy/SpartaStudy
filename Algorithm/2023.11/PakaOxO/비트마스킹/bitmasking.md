## Bitmasking

&nbsp;&nbsp;비트마스킹은 0과 1의 조합으로 데이터를 표현하는 `이진(binary)`수를 자료구조로 활용하는 기법입니다. 0과 1은 각각 boolean값의 false/true와 대응되며 이에 기반해 각 비트 자리수가 0인지 1인지에 따라 해당 숫자를 가지고 있는지를 확인합니다. 가령 0101b라는 이진수가 있다면, 첫째와 셋째자리 비트가 1로 현재 자료구조가 배열을 표현했다면 0과 2를 포함한 배열 [0, 2]를 나타냅니다. 여기서 첫째, 셋째자리가 1인데 각각 0과 2로 표현된 이유는 비트의 shift 연산과 관련이 있습니다. 비트 연산에 대해서는 이제부터 살펴보도록 하겠습니다.

<br>

### 비트 연산(Bit operate)

**1. AND(&) 연산** : 대응되는 자리수의 비트가 모두 1일때 1을 반환합니다.

**2. OR(|) 연산** : 대응되는 자리수의 비트가 둘중 하나라도 1이면 1을, 둘다 0이면 0을 반환합니다.

**3. XOR(^) 연산** : 대응되는 자리수의 비트가 같으면 1, 다르면 0을 반환합니다.

**4. NOT(~) 연산** : 현재 각 자리수의 비트를 반전합니다.

**5. SHIFT(<<, >>) 연산** : 현재 비트를 왼쪽(LEFT SHIFT), 또는 오른쪽(RIGHT SHIFT)로 이동합니다.

<br>

### SHIFT 연산과 비트마스킹

&nbsp;&nbsp;자 이제 비트연산에 대해 간략하게 살펴보았으니 `SHIFT` 연산을 통해 어떻게 자료구조를 표현하는지 알아보도록 하겠습니다. 앞서 0101b라는 이진수가 0과 2를 포함하고 있다고 이야기했었습니다. 만약 1b이라는 이진수를 LEFT SHIFT 연산을 2번 시행했을 때의 비트는 어떻게 될까요?

&nbsp;&nbsp;비트를 왼쪽으로 두번 밀면 100b로 밀어낸 뒤 빈 자리를 0으로 채웁니다. 이렇게 숫자 1을 LEFT SHIFT 연산으로 밀어낸 횟수의 위치에 해당하는 값이 1이면 해당 숫자가 채워져 있음, 즉 자료구조해 2라는 숫자가 포함되어있음을 의미합니다.

&nbsp;&nbsp;다시 돌아와서 0101b라는 이진수에 0과 2라는 숫자가 포함되어 있음을 확인하는 방법은 `AND(&)` 연산을 사용하면 됩니다. 0101b & (1 << 2)라는 비트 연산을 수행하면 0101b & 0100b의 AND 연산으로 정리할 수 있습니다. AND 연산은 각 자리수의 비트가 모두 1일때만 1을 반환하므로 AND 연산의 결과는 0100b를 반환합니다. 따라서 SHIFT 연산과 AND 연산 모두를 실행한 결과가 0보다 크면 해당 숫자가 포함되어있음을 확인할 수 있습니다.