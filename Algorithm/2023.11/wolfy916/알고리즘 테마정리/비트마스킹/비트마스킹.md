# 비트 마스킹

## 비트 연산자
```python
>>> True & False  # and
False
>>> True | False  # or
True
>>> True ^ True   # xor
False
>>> ~ True        # not
-2
```

## 비트 조작
```python
>>> bin(0b1101 >> 2)  # 오른쪽 시프팅
'0b11'
>>> bin(0b1101 << 2)  # 왼쪽 시프팅
'0b110100'
```

## 2의 보수
컴퓨터가 음수를 저장하기 위한 방법

### 컴퓨터에서 양수, 음수 표현 방법
4bit에서 컴퓨터가 양수와 음수를 저장하기 위해 맨 앞 비트를 부호 비트로 사용하여 다음과 같이 양수와 음수를 표현한다고 가정하자.

10진수 5를 4bit 이진수로 표현 => 0101
10진수 -5를 4bit 이진수로 표현 => 1101

5 + (-5) = 0,
두 수의 합은 10000(bit칸을 넘어가면 0000이 되어 값은 0) 또는 0000이 되어야 함. 하지만 0101 + 1101 = 10010이 됨 = >따라서 다음과 같이 표현하면 X

10진수 5는 그대로 0101로 표현한다고 하면, 더해서 0이 되는 값은 1011 !
따라서 10진수 -5는 1011로 표현됨.

그럼 10진수 -5는 1011로 표현하는 방법을 논리화 하면,
=> 0101(=10진수 5)에서 1을 0으로 0을 1로 바꿔줌(보수) + 1 = 1010 + 0001 = 1011
**=> -x = x의 보수 + 1**

### 파이썬의 내부적인 2의 보수 표현
파이썬은 임의 정밀도를 지원하기 때문에 부호는 별도 필드로 갖고 있으며, 비트 연산이 필요할 때만 2의 보수로 변환하는 작업을 진행
```python
print(bin(5))   #0b1출력
print(bin(-5))   #-0b1출력

print(bin(5-5))  #0b0출력
```

### 파이썬에서 2의 보수 출력
```python
# 0b는 2진수, 0x는 16진수 표현
# 15(십진수) = 1111(이진수) = F(16진수)
# 0xF = 4bit 2진수로 표현하면 1111

# 파이썬은 비트 연산할때 2의 보수로 변환하므로 비트 마스크 0b1111을 만들어 &연산한다
#(0b1111와 &연산하면 그대로 출력되니까!)

MASK = 0xF
print(bin(5 & MASK))    #0b101
print(bin(-5 & MASK))   #0b1011
```