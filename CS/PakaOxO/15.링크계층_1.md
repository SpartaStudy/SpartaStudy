## 15. 링크 계층 1

&nbsp;&nbsp;이제껏 각 호스트에서 출발한 패킷은 라우터들을 거쳐 다른 호스트로 이동한다고 이야기 해왔습니다. 하지만 각 라우터는 하나의 호스트와 연결된 것이 아닌 수많은 호스트들과 연결되어 있으며, 이 부분이 바로 링크 계층을 통해 설명될 수 있습니다.

&nbsp;&nbsp;만약 하나의 라우터에 연결되어 있는 여러 호스트가 동시 다발적으로 라우터에게 링크계층 전송단위인 `프레임(Frame)`을 보내게 되면 충돌이 발생해 문제가 생길 수 있는 여지가 있습니다. 이번 장에서는 링크계층에서 이루어지는 다양한 상황들에 대해 알아보겠습니다.

<br>

### 링크계층의 구현

&nbsp;&nbsp;링크계층의 구현부는 유선의 경우, 유선 랜(LAN)을 꽂는 `네트워크 인터페이스`인 이더넷(Ethernet) 카드 내부에 구현되어 있습니다.

<br>

### Multiple Access links

&nbsp;&nbsp;링크계층의 바로 다음 계층인 물리계층에서 실제로 데이터는 전기적 신호에 의해 전달됩니다. 링크계층에서 시작한 전기 신호는 물리계층인 케이블을 통해 연결된 모든 방향으로 전달이 되는데, 마치 broadcast되는 것과 같아 이러한 물리계층을 `broadcast media`라고 부르기도 합니다. 모든 방향으로 전파되는 특성으로 여러 호스트에서 동시에 전기 신호가 출발하면 보강, 상쇄 등의 간섭이 발생해 실제적으로 데이터가 망가지게 됩니다. 이를 방지하기 위해 존재하는 것이 링크계층과 그 프로토콜입니다.

<br>

### MAC Protocols

&nbsp;&nbsp;링크계층에서는 Medium에 대한 Mutiple Access 과정에서 충돌 방지를 위해 다음과 같은 방법들을 제안합니다. 각각의 방법들에 대해 살펴보겠습니다.

1. Channel Partitioning
2. Random Access
3. Taking turns

<br>

**1. Channel Partitioning**

&nbsp;&nbsp;이 방법은 일정한 기준 단위를 잘개 쪼갠 뒤, 쪼개진 슬롯을 사용할 수 있는 기기들을 할당하는 방식입니다. 기준 단위에 따라 시간이면 `Time Division Multiple Access(TDMA)`, 주파수이면 `Frequency Division Multiple Access(FDMA)`입니다.

&nbsp;&nbsp;`TDMA`는 일정한 시간을 잘개 쪼갠 뒤, 쪼개진 슬롯을 사용할 수 있는 기기들을 할당하는 방식입니다. 이렇게 되면 특정 시간에는 하나의 기기만 미디어를 사용하므로 충돌이 발생할 일이 없어집니다. 하지만 슬롯을 이용할 기기의 수가 적으면 빈 슬롯(idle slot)의 개수가 많아져 효율성이 떨어진다는 문제가 있습니다.

&nbsp;&nbsp;마찬가지로 `FDMA`는 주파수를 일정한 단위로 쪼개 슬롯화하여 사용할 수 있는 기기를 배정합니다. 이 역시 사용하는 기기의 수가 적을 수록 남는 슬롯이 발생된다는 단점이 있습니다.

<br>

**2. Random Access**

&nbsp;&nbsp;`Random Access` 방식은 현실에서 가장 많이 사용되는 방법 중 하나입니다. 말 그대로 기기가 데이터를 보내고 싶을 때 언제든지 보낸다는 것이죠. 이 방법을 사용하려면 앞서 살펴보았던 충돌과 관련된 문제를 해결하기 위한 아이디어가 필요합니다. `Random Access` 방식으로 제안된 여러가지 모델 중 가장 대표적인 `CSMA(Carrier Sense Multiple Access)`에 대해서 살펴보겠습니다.

<br>

### CSMA(Carrier Sense Multiple Access)

&nbsp;&nbsp;`CSMA`는 사람들 사이에서 대화를 할때, 다른 사람의 대화를 방해하지 않기 위해 말하기 전 이미 말하고 있는 사람이 있는지 확인(listen)하는 과정을 거치는 것과 같은 아이디어를 사용합니다. 데이터를 보내기 전, 이미 medium을 사용하고 있는 다른 기기가 있는지 확인하는 방법이죠.

**CSMA Collisions**

&nbsp;&nbsp;이러한 아이디어에도 물리적인 한계에 의해 충돌을 아예 막을 수는 없습니다. 물리계층에서 데이터가 전송되는 속도는 빛의 속도에 근접하는데, 결국 `Propagation delay`에 의해 자신에게 전달되기까지의 딜레이로 `Carrier sense`로 비어있는 것을 확인을 한 시점에, 이미 전달되어 오는 데이터가 있을 수 있습니다. 이렇게 원천적으로 충돌을 방지하는 것은 불가능하기 때문에 충돌이 발생했더라도 문제를 최소화하는 것이 중요합니다.

**CSMA/CD(Collision detection)**

1. Carrier Sense를 통해 비어있는 것을 확인하고 데이터를 전송합니다.
2. 모든 Frame이 전송하는 중에 충돌을 감지하면 전송을 취소합니다.
3. 취소된 전송은 `Binary backoff` 알고리즘을 통해 재전송됩니다.
4. `Binary backoff` 알고리즘은 다음과 같습니다.
    - 데이터 충돌이 감지되면 전송을 중단한 뒤 일정시간의 범위 내에서 랜덤한 시간을 골라 재전송을 실시합니다.
    - 재전송되는 시간의 범위는 처음에 작게 시작해 2의 지수의 형태로 exponential하게 증가하는 범위로 증가하며, 충돌이 발생할 때마다 랜덤한 시간의 범위가 증가합니다.
    - 충돌이 반복될 수록 재전송을 위해 Random Access되는 시간의 범위가 증가하므로 오버헤드가 커지게 된다는 단점이 있습니다.

<br>

**3. Taking turns**

&nbsp;&nbsp;`Taking turns` 방식은 중앙 관리자 역할을 하는 `central node` 두어, 이 노드가 다른 노드들에게 보낼 데이터가 있는지 확인한 뒤 하나를 선정해 차례로 데이터를 보내게 하는 방법입니다. 이 경우 충돌이 발생하지는 않지만 별도의 관리 노드를 두어야 하는 점에서 관리용 노드에 문제가 발생하면 데이터 전송이 안되는 `single point failure` 문제점과 별도의 노드를 하나 거쳐야 한다는 점에서 오버헤드 역시 존재합니다.

&nbsp;&nbsp;`Taking turns`의 또 다른 방식에는 `token passing`이 있습니다. 데이터 전송은 토큰을 가진 노드만이 가능하며, 보낼 데이터가 없다면 다른 노드로 토큰을 이동합니다. 이 경우에도 데이터를 보낼 노드에 토큰이 오기까지 기다려야 한다는 점과 별도의 토큰이 전송되는 과정에서 발생하는 오버헤드의 문제점과 함께 한 노드의 오류로 토큰을 잃어버리면 나머지 노드도 데이터 전송을 하지 못한다는 점에서 `single point failure` 문제 역시 존재합니다.