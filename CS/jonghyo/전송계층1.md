# 전송계층 1

## 전송계층

- 어플리케이션 계층에서 메시지를 받아 **다른 편**에 있는 어플리케이션 계층에 **전달**하는 역할.
    - 어플리케이션 계층에서 만들어지는 데이터의 단위 : 메시지
    - 전송계층에서의 데이터 단위 : 세그먼트. ⇒ 어플리케이션 메시지를 담을 `데이터 부문`과 메타데이터 와 같은 부가적인 정보를 담은 `헤더 부문`으로 나누어져있음.
    - 네트워크 계층에서의 데이터 단위 : 패킷
- 전송 계층에서 제공하는 서비스는 TCP와 UDP가 있다.
    - TCP : reliable, in-order delivery, congestion control, flw control, connection setup
    - UDP : unreliable, unordered delivery, no-frills extension of “best-effort” IP
    - 다른 서비스는 제공해주지 않는다.(다른 서비스는 어플리케이션 계층에서 구현해야함)

## 멀티플렉싱 / 디멀티플렉싱

- 멀티플렉싱 : 여러군데에서 정보를 받아 하나의 통으로 보내줌. (보내는 측에서 이루어짐)
- 디멀티플렉싱 : 하나의 정보를 여러군데로 보내줌. (받는 측에서 이루어짐)
    - 디멀티 플렉싱을 할때 포트넘버가 필요함. (어떤 소켓 즉 어떤 프로세스로 보낼지 판단하기 위해서.)
    - 세그먼트의 헤더부분에 포트넘버가 포함이 된다. (source port : sender측 사용 , dest port : receiver측 사용)
- 이 두개의 과정이 전송계층에서 이루어집니다.(소켓 인터페이스를 직접적으로 다루는 계층이니까.)

### UDP의 디멀티 플렉싱

1. 한 유저는 9157 포트에서 소켓을 만들었고 다른 유저는 5775 포트에서 소켓을 만들었고 서버에서 6428 포트에 소켓을 만듬.
2. 9157 포트의 유저가 서버에 메시지를 보내는데 이때 source port 는 9157 이며 dest port 는 6428 이다.
    - 이때 서버에서 물리계층에서 부터 어플리케이션계층까지 올라가 받은 후 서버에서 다시 9157 포트 유저에게 메시지를 전송. 이때 source port 는 6428 dest port 는 9157 이 된다.
    
- UDP의 디멀티플렉싱은 **dest port만** 보고 디멀티 플렉싱을 함. (즉 dest port만 같으면 같은 소켓으로 들어간다.)

### TCP의 디멀티 플렉싱

- source IP 주소
- source port number
- dest IP 주소
- dest port number
- 위의 네개를 통해 디멀티 플렉싱을 이루어냄.
    - 위의 4개중 하나라도 다르다면 다른 소켓을 이용합니다.
    - 보통 dest IP, port는 같지만 source IP, port가 다릅니다.
    - 실제론 사용자를 위해서 각각의 프로세스를 만들지 않는다. 실제론 사용자의 요청이 올때마다 스레드를 만들어 배정을 해줍니다. 각 스레드가 소켓을 사용자의 요청을 처리 담당

### UDP

- 커넥션을 맺기 위한 준비동작 등이 없어 가벼움.
- 위와 같은 커넥션이 없기 때문에 신뢰성이 떨어짐.
- DNS, SNMP, streaming multimedia apps 등 에서 사용한다.
- 기본적으로 2가지 일을함.
    - 멀티플렉싱/ 디멀티플렉싱
    - 에러 검출.

**세그멘트 헤더**

- source port, dest port, length, checksum 총 4가지로 구성
    - 포트번호 : 디멀티플렉싱할때 사용.
    - checksum : data에 들어가는 정보에 에러가 있는지 없는지 판단할 수 있게함.
- 헤더는 작으면 작을수록 좋다. (receiver 측에서는 버려지는 overhead임.)

### Reliable data transfer (신뢰성있는 데이터 전송)

- 실제 전송계층 아래는 신뢰성이 있지 않다.

rdt라는 프로토콜을 사용한다고 가정하자.

- finite state machines(유한 상태 기계)를 사용할 것. ⇒ 주어지는 모든 시간에서 처해 있을 수 있는 유한 개의 상태를 가지고 주어지는 입력에 따라 어떤 상태에서 다른 상태로 전환시키거나 출력이나 액션이 일어나게 하는 장치 또는 그런 장치를 나타낸 모델
- 조건 : sender 는 패킷을 하나 보내는데 receiver가 받았다는 100% 확신이 있을 때만 다음 패킷을 보낼 것.

1.0 아래 채널들이 완벽히 신뢰성이 있었다.

- 패킷 유실도 없고
- 에러도 없는 상황이라면?
    - 단순히 사용자로부터 데이터를 받으면 패킷을 만들고 보내면 됨. receiver는 그것을 받아 사용자에게 데이터 부분만 전해주면 됌.

2.0 패킷 에러가 발생할 수 있다면?

- ACKS or NAKS 를 주자.
    - ACKS : receiver가 패킷을 온전히 받았다면 sender에게 알려주는 것.
    - NAKS : receiver가 패킷에 에러가 있다고 sender에게 알려주는 것.
- error detection 이 필요하며, feedback, retransmission 이 필요하다. (에러를 극복하기 위한 메커니즘.)

2.0 만약 ACK인지 NAKS인지 판단이 안된다면?

- sequence number로 위를 판단함.
    - 각 패킷마다 sequence number가 붙어 있어 receiver입장에서 재전송을 받는 것인지 새로운 것을 받는 것인지 알 수가 있다.
    - header는 작을 수록 좋으니 sequence number는 0,1이면 충분. (0과 1을 번갈아 가면서 사용.)