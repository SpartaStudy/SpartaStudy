# 전송계층 4

## Congestion Control

### Congestion이란?

- 많은 사람들이  다룰 수 있는 네트워크 보다 많은 데이터를 너무 빠르게 보내는것.
- 현상
    - 패킷 손실(라우터에서 버퍼 오버플로우)
    - . 딜레이가 발생.(라우터 버퍼에서 큐잉 발생)

### Congestion이 왜 발생하는가?(시나리오)

### 시나리오 1

- 2명의 발신자와 2명의 수신자가 있다.
- 1개의 라우터가 있고 무한대 큐를 가질 수 있음.
- output link capacitry : R
- 재전송이 일어나지 않음

**througput**? ⇒ 단위 시간당 데이터가 수신자에게 전달되는 단위.

- 단위 시간당 최대 throughput은 R/2이다.(아무리 빨리보내도 R/2에 수렴함.)
- delay는 송신자가 보낸 데이터가 수신자에게 도착하는 시간이라 생각하면됌. ⇒ 속도를 높이면 증가하다가 무한대로 수렴함.

### 시나리오 2

- 1개의 라우터가 있고 큐 사이즈를 가지고 있다.
- 송신자는 TCP 처럼 timeout이 되면 재전송을 한다.
- 송신자는 버퍼에 데이터가 있을 때만 보낸다.
- 위는 시나리오 1과 같이 단위 시간당 최대 throughput이 R/2입니다.
    - 만약 패킷유실이 발생하고 패킷 유실이 있을때만 재전송하는게 추가되었다면?
    - throughput이 R/2까지 도달하는데 기존엔 R/2만 보내주면 되었지만 패킷 유실이 발생 했기 때문에 더 보내주어야 한다. (Λin이 늘어남) ⇒ 실제 보내는 데이터 만큼 받질 못한다.
    - 재전송한 양이 늘어나면 의미있는 데이터가 줄어들기 때문이다.
        - 실제 상황 : 타임아웃이 발생한 경우.
            - 왜 발생? ⇒ congestion이 있기 때문에 발생한다. ⇒ 패킷들이 많이 기다린다. ⇒ 딜레이가 생길수 있다. ⇒ 타임 아웃이 발생할 수 있다. (악순환 반복)
            - throughput도 떨어짐(최대 R/2까지 가지 못함). 필요없는 재전송이 일어나기 때문이다.

### 시나리오 3

- 4명의 송신자가 있다. (A,B,C,D)
    - A는 C와 통신하고 B는 D와 통신한다. 서로 가는길에 겹치는 라우터 존재.
- multihop paths
- 타임아웃이 있고 재전송이 있다.
    - A의 송신량을 엄청 증가시킨다면? ⇒ D에서 B로 보내는 패킷과 같은 라우터를 사용하는데 이때 D에서 보내는 데이터는 드랍된다.
    - Congestion이 발생하면 큐가 점점 차게되고 이후에 오는 애들이 드랍될 확률이 높아짐.
        - ex) D에서 B로 패킷을 보내는데 5개의 라우터를 거쳐야하는데 마지막 5번째 라우터에서 드랍당한다면 이전 라우터에서 사용한 자원이 낭비된다.
    - 네트워크 상황에 맞게 재전송을 해야 낭비를 줄일 수 있다.
        - 네트워크 상황을 판단하는 방법?
            1. 양쪽끝에서 추측해서 네트워크 상태를 짐작하는 방법. ⇒ 단순히 피드백만 가지고 네트워크 상태를 짐작함.
            2. 중간에 있는 네트워크 안에 포함된 라우터가 나에게 정보를 주는 것.
        

### TCP congestion control

**additive increase multiplicative decrease**

- 점차적으로 증가시키고 전송이 막힐 때 감소는 절반으로.
- 윈도우 사이즈 만큼 데이터를 보냄. ⇒ ACK가 잘 왔다면 네트워크 상태가 좋다.(10개의 세그먼트를 보냈는데 10개의 ACK가 옴) ⇒ 점차 보내는 세그먼트가 많아짐. ⇒ ACK가 되돌아 오지 않음. ⇒ 전송 개수를 절반으로 줄임.(반복)
- congestion window의 사이즈는 네트워크 상황에 따라서 값이 변한다.
    - TCP는 한번에 cwnd(congestion window) size만큼 보낼 수 있다.
    - 보낼 수 있는 양은 cwnd/RTT bytes/sec 정도 입니다.

### Slow start

- 처음 송수신을 주고받을 땐 1개를 주고 받으며 2배씩 늘려 줍니다. (무작정 윈도우 사이즈 만큼 보내는 것은 안돼.)
- 그러다 ssthresh수치에 도달하게 되면 1씩 증가 하게 된다. (ssthresh 이후로는 congestion이 발생 할 수 있기 때문이다.) Congestion avoidance 단계.
- 그러다 packet loss가 발생함.
    - 3 duplicate ACK ⇒ 네트워크 상황은 괜찮은데 한 친구만 제대로 못감.
    - Time out ⇒ 내가 보낸 세그먼트가 거의 살아남지 못하고 중간에 다 죽음(네트워크 상황이 좋지않음)
- 이전버전 ⇒ 초기화 시켜 다시 1부터 진행하는데 ssthresh가 window가 초기화된 것의 절반으로 바뀜
- 최신버전(TCP Reno) ⇒ 시작을 window가 터진것 부터 시작하는데 1씩 증가함.

### TCP throughput

- 평균 값이 3/4 * W/RTT bytes/sec 이다.

### TCP Fairness

- TCP에 대한 동작은 주변에 상관없이 독립적으로 하는 것.
- 예로 라우터의 캐패시터가 R인데 2명에서 사용중이라면 정말 R/2로 나뉠까?
    - TCP는 결과적으로 R/2로 수렴하게 만듦.
    - 1/N씩 공평하게 만들어주려고 함.
    - UDP는 아님.