### Q. TCP와 UDP Segment Header 필드별로 간단한 설명.

    TCP: 출발port, 도착port, SEQ넘버, ACK넘버, 플래그, 윈도우 사이즈, 체크섬, urgent point

        - port: 출발지와 목적지의 포트 번호
        - SEQ: 순서 번호
        - ACK: 세그먼트를 잘 받았다는 것을 알려주기 위한 번호
        - 플래그: 세그먼트의 종류를 표시, 6개의 비트로 구성되며 "URG-ACK-PSH-RST-SYN-FIN"의 의미를 가진다.
        - 윈도우 사이즈: 한번에 전송할 수 있는 최대 바이트 수
        - 체크섬: 헤더와 데이터의 에러를 확인하기 위한 필드
        - urgent: 긴급한 데이터임을 표시

    UDP: 출발port, 도착port, 전체 헤더의 크기, 체크섬

        - port: 출발지와 목적지의 포트 번호
        - length: 헤더와 데이터를 포함한 전체 크기
        - 체크섬: 헤더와 데이터의 에러를 확인하기 위한 필드

### Q. TCP가 Reliable Transmission을 제공하는 방법에 대한 설명.

    TCP의 수신자는 segment를 제대로 수신하면 ACK, 제대로 수신 못했으면 NAK를 보낸다. 이를 이용하여 데이터가 정상적으로 전송되었는지 확인할 수 있다.

    체크섬 필드를 이용한다. TCP헤더들을 16비트로 잘라서 16비트들의 1의 보수의 합을 저장한다. 체크섬이 일치하는지를 비교하여 segment가 손상되었는지 판단할 수 있다.

    수신자가 ACK, NAK을 못보내는 경우 타이머를 이용해 재전송한다. segment를 보낼 때 타이머를 작동시켜 타임아웃이 발생할 경우 segment를 재전송한다.

    segment의 SEQ넘버를 이용해 데이터들의 순서를 보장한다. 수신자에서는 수신한 segment를 바로 전달하지않고 버퍼에 가지고있다가 SEQ넘버를 이용해 순서가 맞을 때까지 기다리고 순서가 맞춰진 데이터를 전달한다.

### Q. TCP가 Congestion Control과 Flow Control를 제공하는 방법.

    - 혼잡제어(Congestion Control)

        네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 방지하거나 제거하는 기능이다.

        1. AIMD: 처음에 하나의 패킷을 전송하여 문제없이 도착하는 것을 확인하면 윈도우 사이즈를 하나 늘려 2개를 보낸다. 이런식으로 하나씩 늘려나가다가 패킷이 전송되지 않거나 타임아웃이 발생하면 윈도우 사이즈를 반으로 줄인다.

        2. Slow Start: 처음에 패킷을 하나씩 전송한다. 패킷이 문제없이 도착하면 각각의 패킷마다 윈도우 사이즈를 하나씩 증가시킨다. 즉, 윈도우 사이즈를 2배씩 증가시킨다. 혼잡현상이 발생 시 윈도우 사이즈를 1로 줄인다.

    - 흐름제어(Flow Control)

        송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기능이다. 송신측의 속도가 너무 빨라 한 번에 많은 패킷을 수신받는다면 버퍼가 가득 차 손실되는 패킷들이 발생한다.

        1. Stop-And-Wait: 매번 전송한 패킷에 대한 확인 응답을 받아야만 다음 패킷을 전송한다.

        2. Sliding Window: 수신측에서 설정한 윈도우 사이즈만큼 송신측에서 패킷 각각에 대한 확인 응답없이 segment를 전송하게하여 데이터 흐름을 동적으로 제어한다.

### Q. Fast-retransmit에 대한 설명과 Fast-retransmit이 필요한 이유.

    타이머의 타임아웃 기간이 너무 길어 타이머가 종료되기 전이라도 중복된 ACK를 3번 받으면 바로 재전송하는 기능이다. 이를 통해 손실된 패킷을 재전송하기 전 발생하는 긴 지연시간을 줄여준다.

### Q. TCP Connection과 TCP Closing 과정을 단계별로 설명(Segment 필드값을 예시로 설명할 것)

    - 연결: 3 way handshake

        1. (클라이언트 -> 서버) 클라이언트가 서버에게 SYN패킷을 보낸다.

            control비트의 syn플래그 1로 설정.
            seq넘버 x로 설정.

        2. (서버 -> 클라이언트) 서버가 SYN을 받고 클라이언트로 받았다는 신호인 ACK와 SYN패킷을 보낸다.

            control비트 syn플래그 1, ack플래그 1로 설정.
            seq넘버 y로 설정, ack넘버 x + 1로 설정.

        3. (클라이언트 -> 서버) 클라이언트는 서버의 응답으로 ACK와 SYN패킷을 받고, ACK를 서버로 보낸다.

            control비트 ack플래그 1로 설정.
            seq넘버 x + 1, ack넘버 y + 1로 설정.

    - 연결 해제: 4 way handshake

        1. (클라이언트 -> 서버) 클라이언트는 서버에게 연결을 종료한다는 FIN플래그를 보낸다.

            control비트의 fin플래그 1로 설정.
            seq넘버 x로 설정.

        2. (서버 -> 클라이언트) 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. 이때, 모든 데이터를 보내기 위해 close wait 상태가 된다.

            control비트 fin플래그 1, ack플래그 1로 설정.
            seq넘버 y로 설정, ack넘버 x + 1로 설정.

        3. (서버 -> 클라이언트) 데이터를 모두 보냈다면, 연결이 종료되었다는 FIN플래그를 클라이언트에게 보낸다.

            control비트 fin플래그 1, ack플래그 1로 설정.
            seq넘버 y로 설정, ack넘버 x + 1로 설정.

        4. (클라이언트 -> 서버) 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에 보낸다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 time wait를 통해 기다린다. 서버는 ACK를 받은 이후 close, 클라이언트는 time wait시간 종료 후 close.

            control비트 ack플래그 1로 설정.
            seq넘버 x + 1, ack넘버 y + 1로 설정.
